library(pegas)

#initial stuff to run as example
distanceMatrix <- matrix(c(0,3,14,12,3,0,13,11,14,13,0,4,12,11,4,0), nrow = 4, ncol = 4)
distanceMatrixFix <- distanceMatrix
rownames(distanceMatrix) <- c("H1", "H2", "H3", "H4")
listJunctions <- c("H1", "H2", "H3", "H4")


#script to create a neighbour joining tree as described by wikipedia

haplonet <- matrix(ncol = 3, nrow = 0)

# contains all the junction points like the initial haplotypes and the added junctions
#listJunctions <- labels(haplotypes)

numberTotalHaplotypes <- dim(distanceMatrix)[1]

counter <- 1
while(dim(distanceMatrix)[1] > 2){
  dimensionDistanceMatrix <- dim(distanceMatrix)
  numberRemainingHaplotypes <- dim(distanceMatrix)[1]
  
  #step a - calculate average distances between the remaining taxas of the network (added junctions and haplotypes)
  distanceVector <- vector(length = numberRemainingHaplotypes)
  for (i in 1: numberRemainingHaplotypes){
    distanceVector[i] <- sum(distanceMatrix[i,])/(numberRemainingHaplotypes-2) 
  }
  
  #step b - calculate temporary matrix m containing the differences between the remaining taxas
  m = matrix(nrow = dimensionDistanceMatrix[1], ncol = dimensionDistanceMatrix[2])
  for (i in 1: dimensionDistanceMatrix[1]){
    for (j in 1: dimensionDistanceMatrix[2]){
      if(i!=j){
        m[i,j] = distanceMatrix[i,j] - (distanceVector[i] + distanceVector[j])
        next
      }
      m[i,j] =  0
    }
  }
  
  #step c - combine two taxas with the smallest difference to subtaxa u 
  #search for smallest value in m
  u <- which(m == min(m), arr.ind = TRUE)[1,]
  

  #calculate edge lengths between parent taxas and subtaxa 
  vi <- (unname(distanceMatrix[u[1],u[2]]) + distanceVector[u[1]] - distanceVector[u[2]]) / 2
  vj <- unname(distanceMatrix[u[1],u[2]]) - vi

  #extendDistanceMatrix by subtaxa u by calculating distances from u to the other remaining taxa 
  # calculated distances will be stored in v
  v <- vector(length = dimensionDistanceMatrix[1] + 1)
  for (i in 1: dimensionDistanceMatrix[1]){
    v[i] <- (distanceMatrix[u[1],i] + distanceMatrix[u[2],i] - distanceMatrix[u[1],u[2]])/2
  }
  v[length(v)] <- 0
  #extend distance Matrix by v
  distanceMatrix <- rbind(distanceMatrix, v[1:length(v)-1])
  distanceMatrix <- cbind(distanceMatrix, v)
  
  #add new rowname for u to distance matrix and listJunctions
  rownames(distanceMatrix) <- append(rownames(distanceMatrix)[1:length(rownames(distanceMatrix))-1], paste("u",toString(counter), sep =""))
  listJunctions <- append(listJunctions, paste("u", toString(counter), sep = ""))
  
  # add new edges between the two parentTaxa and subtaxa u with previously calculated distances vi and vj
  ui <- which(listJunctions == rownames(distanceMatrix)[u[1]])
  uj <- which(listJunctions == rownames(distanceMatrix)[u[2]])
  uimin <- min(ui, numberTotalHaplotypes + counter)
  uimax <- max(ui, numberTotalHaplotypes + counter)
  ujmin <- min(uj, numberTotalHaplotypes + counter)
  ujmax <- max(uj, numberTotalHaplotypes + counter) 
  
  haplonet <- rbind(haplonet, c(uimin, uimax, ceiling(vi)))
  haplonet <- rbind(haplonet, c(ujmin, ujmax, ceiling(vj)))
  
  #delete old parenttaxas of u from distance matrix
  distanceMatrix <- distanceMatrix[-max(u),-max(u)]
  distanceMatrix <- distanceMatrix[-min(u),-min(u)]
  
  counter <- counter + 1
}

#combine last two remaining clusters
ui <- which(listJunctions == rownames(distanceMatrix)[1])
uj <- which(listJunctions == rownames(distanceMatrix)[2])
haplonet<- rbind(haplonet, c(min(ui,uj), max(ui,uj), ceiling(distanceMatrix[1,2])))

#chande some attributes to addapt haplonet matrix to pegas haplonets
colnames(haplonet) <- c("","","step")
listJunctions[(numberTotalHaplotypes + 1) : length(listJunctions)] <- " "
attr(haplonet, "labels") <- listJunctions
attr(haplonet, "data") <- vcfData
attr(haplonet, "prefix") <- " "
class(haplonet) <- c("mjn", "haploNet")







# calculation of tree distances
numberNodes <- length(attr(haplonet, "labels"))
treeDistanceMatrix <- matrix(nrow = numberNodes, ncol = numberNodes)
for (i in 1:numberNodes){
  for (j in 1:numberNodes){
    if (i == j) 
      treeDistanceMatrix[i,j] <- 0
    if(j < i){
      treeDistanceMatrix[i,j] <- treeDistanceMatrix[j,i]
    }
    #calculate distance between node i and node j
    
  }
}








# minimising tree by checkign each node, whether it connects two haplotypes, 
# then deleting one edge 
# and put haplotype with smallest average distance in position of the deleted node

numberTotalHaplotypes
numberAdditionalNodes <- length(attr(haplonet, "labels")) - numberTotalHaplotypes

edgesToBeChecked <- dim(haplonet)[1] #vector(length = numberTotalHaplotypes + numberAdditionalNodes)

#node <- listJunctions[numberTotalHaplotypes + i]
nodeAsInt <- which(listJunctions == " ")


averageDistanceVector <- vector(length = numberTotalHaplotypes)
for (i in 1: numberTotalHaplotypes){
  averageDistanceVector[i] <- sum(distanceMatrixFix[i,])/(numberTotalHaplotypes-2) 
}

#edgesToBeChecked <- matrix(ncol = dim(haplonet)[1], nrow = 0)
replaceMatrix <- matrix(nrow = 0, ncol = 5)

#iterate over all added nodes to find replacing candidates and their replacors
for(i in 1:numberAdditionalNodes){
  #browser()
  edgesToBeChecked[1:length(edgesToBeChecked)] <- FALSE
  edgesToBeChecked[which(haplonet[,1] == nodeAsInt[i])] <- TRUE
  edgesToBeChecked[which(haplonet[,2] == nodeAsInt[i])] <- TRUE
  #edgesToBeChecked <- rbind(edgesToBeChecked, edgesToBeChecked)
  
  x <- which(edgesToBeChecked[i,] == TRUE)
  whichHaplotypesAreConnected <- vector(length = 0)
  
  for (edge in x){
    if ((haplonet[edge,1] <= numberTotalHaplotypes)){
      whichHaplotypesAreConnected <- append(whichHaplotypesAreConnected, haplonet[edge,1])
    }
    if ((haplonet[edge,2] <= numberTotalHaplotypes)){
      whichHaplotypesAreConnected <- append(whichHaplotypesAreConnected, haplonet[edge,2])
    }
  }
  if(length(whichHaplotypesAreConnected) > 1){
    #replace Edge by haplotype with smallest average Distance
    haplotypeToReplaceNode <- which(averageDistanceVector[whichHaplotypesAreConnected] == min(averageDistanceVector[whichHaplotypesAreConnected]))
    replaceMatrix <- rbind(nodeAsInt, haplotypeToReplaceNode, x)
  }
}

for(i in dim(replaceMatrix[1])){
  
}




#browser()







